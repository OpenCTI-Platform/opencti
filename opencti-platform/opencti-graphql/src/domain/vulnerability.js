import { createEntity } from '../database/middleware';
import { listEntities, listEntitiesThroughRelationsPaginated, storeLoadById } from '../database/middleware-loader';
import { BUS_TOPICS } from '../config/conf';
import { notify } from '../database/redis';
import { ENTITY_TYPE_VULNERABILITY } from '../schema/stixDomainObject';
import { ABSTRACT_STIX_DOMAIN_OBJECT } from '../schema/general';
import { RELATION_HAS } from '../schema/stixCoreRelationship';
import { ENTITY_SOFTWARE } from '../schema/stixCyberObservable';
import {
  isValidCvss2Vector,
  isValidCvss3Vector,
  isValidCvss4Vector,
  parseCvss2Vector,
  parseCvss3Vector,
  parseCvss4Vector,
  updateCvss2Vector,
  updateCvss3VectorWithScores,
  updateCvss4Vector
} from '../utils/vulnerabilities';
import { FunctionalError } from '../config/errors';
import { isNotEmptyField } from '../database/utils';

export const CVSS_SEVERITY_VALUES = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'Unknown'];

export const findById = (context, user, vulnerabilityId) => {
  return storeLoadById(context, user, vulnerabilityId, ENTITY_TYPE_VULNERABILITY);
};

export const findAll = (context, user, args) => {
  return listEntities(context, user, [ENTITY_TYPE_VULNERABILITY], args);
};

export const addVulnerability = async (context, user, vulnerability) => {
  let finalVulnerability = vulnerability;

  // CVSS 4
  if (isNotEmptyField(vulnerability.x_opencti_cvss_v4_vector)) {
    if (!isValidCvss4Vector(vulnerability.x_opencti_cvss_v4_vector)) {
      throw FunctionalError('This is not a valid CVSS4 vector');
    }
    finalVulnerability = { ...vulnerability, ...parseCvss4Vector(vulnerability.x_opencti_cvss_v4_vector, vulnerability.x_opencti_cvss_v4_base_score, true) };
  } else if (Object.keys(finalVulnerability).some((k) => k.startsWith('x_opencti_cvss_v4_'))) {
    const vectorPartsKeys = Object.keys(finalVulnerability).filter((k) => k.startsWith('x_opencti_cvss_v4_') && !k.includes('base'));
    if (vectorPartsKeys.length > 0) {
      finalVulnerability = {
        ...vulnerability,
        ...updateCvss4Vector('', vectorPartsKeys.map((key) => ({
          key,
          value: finalVulnerability[key],
        })), vulnerability.x_opencti_cvss_v4_base_score, true)
      };
    }
  }

  // CVSS 3
  if (isNotEmptyField(vulnerability.x_opencti_cvss_vector)) {
    if (!isValidCvss3Vector(vulnerability.x_opencti_cvss_vector)) {
      throw FunctionalError('This is not a valid CVSS3 vector');
    }
    const parsedVector = parseCvss3Vector(vulnerability.x_opencti_cvss_v4_vector, vulnerability.x_opencti_cvss_base_score, true);
    finalVulnerability = { ...vulnerability, ...parsedVector };
  } else if (Object.keys(finalVulnerability).some((k) => k.startsWith('x_opencti_cvss_'))) {
    const vectorPartsKeys = Object.keys(finalVulnerability).filter((k) => k.startsWith('x_opencti_cvss_') && !k.includes('base') && !k.includes('temporal') && !k.startsWith('x_opencti_cvss_v'));
    if (vectorPartsKeys.length > 0) {
      finalVulnerability = {
        ...vulnerability,
        ...updateCvss3VectorWithScores('', vectorPartsKeys.map((key) => ({
          key,
          value: finalVulnerability[key],
        })), vulnerability.x_opencti_cvss_base_score, true)
      };
    }
  }

  // CVSS 2
  if (isNotEmptyField(vulnerability.x_opencti_cvss_v2_vector)) {
    if (!isValidCvss2Vector(vulnerability.x_opencti_cvss_v2_vector)) {
      throw FunctionalError('This is not a valid CVSS2 vector');
    }
    const parsedVector = parseCvss2Vector(vulnerability.x_opencti_cvss_v4_vector, vulnerability.x_opencti_cvss_v2_base_score, true);
    finalVulnerability = { ...vulnerability, ...parsedVector };
  } else if (Object.keys(finalVulnerability).some((k) => k.startsWith('x_opencti_cvss_v2_'))) {
    const vectorPartsKeys = Object.keys(finalVulnerability).filter((k) => k.startsWith('x_opencti_cvss_v2_') && !k.includes('base') && !k.includes('temporal'));
    if (vectorPartsKeys.length > 0) {
      finalVulnerability = {
        ...vulnerability,
        ...updateCvss2Vector('', vectorPartsKeys.map((key) => ({
          key,
          value: finalVulnerability[key],
        })), vulnerability.x_opencti_cvss_v2_base_score, true)
      };
    }
  }

  const created = await createEntity(context, user, finalVulnerability, ENTITY_TYPE_VULNERABILITY);
  return notify(BUS_TOPICS[ABSTRACT_STIX_DOMAIN_OBJECT].ADDED_TOPIC, created, user);
};

export const softwarePaginated = async (context, user, vulnerabilityId, opts) => {
  return listEntitiesThroughRelationsPaginated(context, user, vulnerabilityId, opts.relationshipType ?? RELATION_HAS, ENTITY_SOFTWARE, true, opts);
};
