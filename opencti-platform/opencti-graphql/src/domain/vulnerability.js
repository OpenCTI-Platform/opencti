import { createEntity } from '../database/middleware';
import { pageEntitiesConnection, pageRegardingEntitiesConnection, storeLoadById } from '../database/middleware-loader';
import { BUS_TOPICS } from '../config/conf';
import { notify } from '../database/redis';
import { ENTITY_TYPE_VULNERABILITY } from '../schema/stixDomainObject';
import { ABSTRACT_STIX_DOMAIN_OBJECT } from '../schema/general';
import { RELATION_HAS } from '../schema/stixCoreRelationship';
import { ENTITY_SOFTWARE } from '../schema/stixCyberObservable';
import { isValidCvssVector, parseCvssVector, updateCvssVector } from '../utils/vulnerabilities';
import { FunctionalError } from '../config/errors';
import { isNotEmptyField } from '../database/utils';

export const CVSS_SEVERITY_VALUES = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'Unknown'];

export const findById = (context, user, vulnerabilityId) => {
  return storeLoadById(context, user, vulnerabilityId, ENTITY_TYPE_VULNERABILITY);
};

export const findVulnerabilityPaginated = (context, user, args) => {
  return pageEntitiesConnection(context, user, [ENTITY_TYPE_VULNERABILITY], args);
};

export const addVulnerability = async (context, user, vulnerability) => {
  let finalVulnerability = vulnerability;

  // CVSS 2
  if (isNotEmptyField(vulnerability.x_opencti_cvss_v2_vector_string)) {
    if (!isValidCvssVector('cvss2', vulnerability.x_opencti_cvss_v2_vector_string)) {
      throw FunctionalError('This is not a valid CVSS2 vector', { vector: vulnerability.x_opencti_cvss_v2_vector_string });
    }
    const parsedVector = parseCvssVector('cvss2', vulnerability.x_opencti_cvss_v2_vector_string, vulnerability.x_opencti_cvss_v2_base_score, true);
    finalVulnerability = { ...finalVulnerability, ...parsedVector };
  } else if (Object.keys(finalVulnerability).some((k) => k.startsWith('x_opencti_cvss_v2_'))) {
    const vectorPartsKeys = Object.keys(finalVulnerability).filter((k) => k.startsWith('x_opencti_cvss_v2_') && !k.includes('base') && !k.includes('temporal'));
    if (vectorPartsKeys.length > 0) {
      finalVulnerability = {
        ...finalVulnerability,
        ...updateCvssVector('cvss2', '', vectorPartsKeys
          .filter((key) => isNotEmptyField(finalVulnerability[key]))
          .map((key) => ({
            key,
            value: finalVulnerability[key],
          })), vulnerability.x_opencti_cvss_v2_base_score, true)
      };
    }
  }

  // CVSS 3
  if (isNotEmptyField(vulnerability.x_opencti_cvss_vector_string)) {
    if (!isValidCvssVector('cvss3', vulnerability.x_opencti_cvss_vector_string)) {
      throw FunctionalError('This is not a valid CVSS3 vector', { vector: vulnerability.x_opencti_cvss_vector_string });
    }
    finalVulnerability = { ...finalVulnerability, ...parseCvssVector('cvss3', vulnerability.x_opencti_cvss_vector_string, vulnerability.x_opencti_cvss_base_score, true) };
  } else if (Object.keys(finalVulnerability).some((k) => k.startsWith('x_opencti_cvss_'))) {
    const vectorPartsKeys = Object.keys(finalVulnerability).filter((k) => k.startsWith('x_opencti_cvss_') && !k.includes('base') && !k.includes('temporal') && !k.startsWith('x_opencti_cvss_v'));
    if (vectorPartsKeys.length > 0) {
      finalVulnerability = {
        ...finalVulnerability,
        ...updateCvssVector('cvss3', '', vectorPartsKeys
          .filter((key) => isNotEmptyField(finalVulnerability[key]))
          .map((key) => ({
            key,
            value: finalVulnerability[key],
          })), vulnerability.x_opencti_cvss_base_score, true)
      };
    }
  }

  // CVSS 4
  if (isNotEmptyField(vulnerability.x_opencti_cvss_v4_vector_string)) {
    if (!isValidCvssVector('cvss4', vulnerability.x_opencti_cvss_v4_vector_string)) {
      throw FunctionalError('This is not a valid CVSS4 vector', { vector: vulnerability.x_opencti_cvss_v4_vector_string });
    }
    finalVulnerability = { ...finalVulnerability, ...parseCvssVector('cvss4', vulnerability.x_opencti_cvss_v4_vector_string, vulnerability.x_opencti_cvss_v4_base_score, true) };
  } else if (Object.keys(finalVulnerability).some((k) => k.startsWith('x_opencti_cvss_v4_'))) {
    const vectorPartsKeys = Object.keys(finalVulnerability).filter((k) => k.startsWith('x_opencti_cvss_v4_') && !k.includes('base'));
    if (vectorPartsKeys.length > 0) {
      finalVulnerability = {
        ...finalVulnerability,
        ...updateCvssVector('cvss4', '', vectorPartsKeys
          .filter((key) => isNotEmptyField(finalVulnerability[key]))
          .map((key) => ({
            key,
            value: finalVulnerability[key],
          })), vulnerability.x_opencti_cvss_v4_base_score, true)
      };
    }
  }

  const created = await createEntity(context, user, finalVulnerability, ENTITY_TYPE_VULNERABILITY);
  return notify(BUS_TOPICS[ABSTRACT_STIX_DOMAIN_OBJECT].ADDED_TOPIC, created, user);
};

export const softwarePaginated = async (context, user, vulnerabilityId, opts) => {
  return pageRegardingEntitiesConnection(context, user, vulnerabilityId, opts.relationshipType ?? RELATION_HAS, ENTITY_SOFTWARE, true, opts);
};
